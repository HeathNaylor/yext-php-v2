<?php
/**
 * ReviewsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * developer.yext.com
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ReviewsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ReviewsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation commentCreate
     *
     * Comment: Create
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\CommentCreateRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function commentCreate($api_key, $v, $content_type, $body, $account_id, $review_id)
    {
        $this->commentCreateWithHttpInfo($api_key, $v, $content_type, $body, $account_id, $review_id);
    }

    /**
     * Operation commentCreateWithHttpInfo
     *
     * Comment: Create
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\CommentCreateRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function commentCreateWithHttpInfo($api_key, $v, $content_type, $body, $account_id, $review_id)
    {
        $returnType = '';
        $request = $this->commentCreateRequest($api_key, $v, $content_type, $body, $account_id, $review_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation commentCreateAsync
     *
     * Comment: Create
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\CommentCreateRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function commentCreateAsync($api_key, $v, $content_type, $body, $account_id, $review_id)
    {
        return $this->commentCreateAsyncWithHttpInfo($api_key, $v, $content_type, $body, $account_id, $review_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation commentCreateAsyncWithHttpInfo
     *
     * Comment: Create
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\CommentCreateRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function commentCreateAsyncWithHttpInfo($api_key, $v, $content_type, $body, $account_id, $review_id)
    {
        $returnType = '';
        $request = $this->commentCreateRequest($api_key, $v, $content_type, $body, $account_id, $review_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'commentCreate'
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\CommentCreateRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function commentCreateRequest($api_key, $v, $content_type, $body, $account_id, $review_id)
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling commentCreate'
            );
        }
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling commentCreate'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling commentCreate'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling commentCreate'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling commentCreate'
            );
        }
        // verify the required parameter 'review_id' is set
        if ($review_id === null || (is_array($review_id) && count($review_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $review_id when calling commentCreate'
            );
        }

        $resourcePath = '/accounts/{accountId}/reviews/{reviewId}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['api_key'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($v !== null) {
            $queryParams['v'] = ObjectSerializer::toQueryValue($v);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($review_id !== null) {
            $resourcePath = str_replace(
                '{' . 'reviewId' . '}',
                ObjectSerializer::toPathValue($review_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewGenerationSettingsGet
     *
     * Review Generation Settings: Get
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reviewGenerationSettingsGet($api_key, $v, $account_id)
    {
        $this->reviewGenerationSettingsGetWithHttpInfo($api_key, $v, $account_id);
    }

    /**
     * Operation reviewGenerationSettingsGetWithHttpInfo
     *
     * Review Generation Settings: Get
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewGenerationSettingsGetWithHttpInfo($api_key, $v, $account_id)
    {
        $returnType = '';
        $request = $this->reviewGenerationSettingsGetRequest($api_key, $v, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reviewGenerationSettingsGetAsync
     *
     * Review Generation Settings: Get
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewGenerationSettingsGetAsync($api_key, $v, $account_id)
    {
        return $this->reviewGenerationSettingsGetAsyncWithHttpInfo($api_key, $v, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewGenerationSettingsGetAsyncWithHttpInfo
     *
     * Review Generation Settings: Get
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewGenerationSettingsGetAsyncWithHttpInfo($api_key, $v, $account_id)
    {
        $returnType = '';
        $request = $this->reviewGenerationSettingsGetRequest($api_key, $v, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewGenerationSettingsGet'
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewGenerationSettingsGetRequest($api_key, $v, $account_id)
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling reviewGenerationSettingsGet'
            );
        }
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling reviewGenerationSettingsGet'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling reviewGenerationSettingsGet'
            );
        }

        $resourcePath = '/accounts/{accountId}/reviews/settings/generation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['api_key'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($v !== null) {
            $queryParams['v'] = ObjectSerializer::toQueryValue($v);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewGenerationSettingsUpdate
     *
     * Review Generation Settings: Update
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewGenerationSettingsUpdateRequest $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reviewGenerationSettingsUpdate($api_key, $v, $content_type, $body, $account_id)
    {
        $this->reviewGenerationSettingsUpdateWithHttpInfo($api_key, $v, $content_type, $body, $account_id);
    }

    /**
     * Operation reviewGenerationSettingsUpdateWithHttpInfo
     *
     * Review Generation Settings: Update
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewGenerationSettingsUpdateRequest $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewGenerationSettingsUpdateWithHttpInfo($api_key, $v, $content_type, $body, $account_id)
    {
        $returnType = '';
        $request = $this->reviewGenerationSettingsUpdateRequest($api_key, $v, $content_type, $body, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reviewGenerationSettingsUpdateAsync
     *
     * Review Generation Settings: Update
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewGenerationSettingsUpdateRequest $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewGenerationSettingsUpdateAsync($api_key, $v, $content_type, $body, $account_id)
    {
        return $this->reviewGenerationSettingsUpdateAsyncWithHttpInfo($api_key, $v, $content_type, $body, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewGenerationSettingsUpdateAsyncWithHttpInfo
     *
     * Review Generation Settings: Update
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewGenerationSettingsUpdateRequest $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewGenerationSettingsUpdateAsyncWithHttpInfo($api_key, $v, $content_type, $body, $account_id)
    {
        $returnType = '';
        $request = $this->reviewGenerationSettingsUpdateRequest($api_key, $v, $content_type, $body, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewGenerationSettingsUpdate'
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewGenerationSettingsUpdateRequest $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewGenerationSettingsUpdateRequest($api_key, $v, $content_type, $body, $account_id)
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling reviewGenerationSettingsUpdate'
            );
        }
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling reviewGenerationSettingsUpdate'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling reviewGenerationSettingsUpdate'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling reviewGenerationSettingsUpdate'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling reviewGenerationSettingsUpdate'
            );
        }

        $resourcePath = '/accounts/{accountId}/reviews/settings/generation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['api_key'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($v !== null) {
            $queryParams['v'] = ObjectSerializer::toQueryValue($v);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewInvitationGet
     *
     * Review Invitation: Get
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     * @param  string $invitation_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reviewInvitationGet($api_key, $v, $account_id, $invitation_id)
    {
        $this->reviewInvitationGetWithHttpInfo($api_key, $v, $account_id, $invitation_id);
    }

    /**
     * Operation reviewInvitationGetWithHttpInfo
     *
     * Review Invitation: Get
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     * @param  string $invitation_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewInvitationGetWithHttpInfo($api_key, $v, $account_id, $invitation_id)
    {
        $returnType = '';
        $request = $this->reviewInvitationGetRequest($api_key, $v, $account_id, $invitation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reviewInvitationGetAsync
     *
     * Review Invitation: Get
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     * @param  string $invitation_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewInvitationGetAsync($api_key, $v, $account_id, $invitation_id)
    {
        return $this->reviewInvitationGetAsyncWithHttpInfo($api_key, $v, $account_id, $invitation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewInvitationGetAsyncWithHttpInfo
     *
     * Review Invitation: Get
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     * @param  string $invitation_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewInvitationGetAsyncWithHttpInfo($api_key, $v, $account_id, $invitation_id)
    {
        $returnType = '';
        $request = $this->reviewInvitationGetRequest($api_key, $v, $account_id, $invitation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewInvitationGet'
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     * @param  string $invitation_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewInvitationGetRequest($api_key, $v, $account_id, $invitation_id)
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling reviewInvitationGet'
            );
        }
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling reviewInvitationGet'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling reviewInvitationGet'
            );
        }
        // verify the required parameter 'invitation_id' is set
        if ($invitation_id === null || (is_array($invitation_id) && count($invitation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invitation_id when calling reviewInvitationGet'
            );
        }

        $resourcePath = '/accounts/{accountId}/reviewinvites/{invitationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['api_key'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($v !== null) {
            $queryParams['v'] = ObjectSerializer::toQueryValue($v);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($invitation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'invitationId' . '}',
                ObjectSerializer::toPathValue($invitation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewInvitationUpdateMetadata
     *
     * Review Invitation: Update Metadata
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewInvitationUpdateMetadataRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $invitation_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reviewInvitationUpdateMetadata($api_key, $v, $content_type, $body, $account_id, $invitation_id)
    {
        $this->reviewInvitationUpdateMetadataWithHttpInfo($api_key, $v, $content_type, $body, $account_id, $invitation_id);
    }

    /**
     * Operation reviewInvitationUpdateMetadataWithHttpInfo
     *
     * Review Invitation: Update Metadata
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewInvitationUpdateMetadataRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $invitation_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewInvitationUpdateMetadataWithHttpInfo($api_key, $v, $content_type, $body, $account_id, $invitation_id)
    {
        $returnType = '';
        $request = $this->reviewInvitationUpdateMetadataRequest($api_key, $v, $content_type, $body, $account_id, $invitation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reviewInvitationUpdateMetadataAsync
     *
     * Review Invitation: Update Metadata
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewInvitationUpdateMetadataRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $invitation_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewInvitationUpdateMetadataAsync($api_key, $v, $content_type, $body, $account_id, $invitation_id)
    {
        return $this->reviewInvitationUpdateMetadataAsyncWithHttpInfo($api_key, $v, $content_type, $body, $account_id, $invitation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewInvitationUpdateMetadataAsyncWithHttpInfo
     *
     * Review Invitation: Update Metadata
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewInvitationUpdateMetadataRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $invitation_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewInvitationUpdateMetadataAsyncWithHttpInfo($api_key, $v, $content_type, $body, $account_id, $invitation_id)
    {
        $returnType = '';
        $request = $this->reviewInvitationUpdateMetadataRequest($api_key, $v, $content_type, $body, $account_id, $invitation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewInvitationUpdateMetadata'
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewInvitationUpdateMetadataRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $invitation_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewInvitationUpdateMetadataRequest($api_key, $v, $content_type, $body, $account_id, $invitation_id)
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling reviewInvitationUpdateMetadata'
            );
        }
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling reviewInvitationUpdateMetadata'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling reviewInvitationUpdateMetadata'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling reviewInvitationUpdateMetadata'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling reviewInvitationUpdateMetadata'
            );
        }
        // verify the required parameter 'invitation_id' is set
        if ($invitation_id === null || (is_array($invitation_id) && count($invitation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invitation_id when calling reviewInvitationUpdateMetadata'
            );
        }

        $resourcePath = '/accounts/{accountId}/reviewinvites/{invitationId}:updatemetadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['api_key'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($v !== null) {
            $queryParams['v'] = ObjectSerializer::toQueryValue($v);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($invitation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'invitationId' . '}',
                ObjectSerializer::toPathValue($invitation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewInvitationsCreate
     *
     * Review Invitations: Create
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewInvitations3ACreateRequest[] $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reviewInvitationsCreate($api_key, $v, $content_type, $body, $account_id)
    {
        $this->reviewInvitationsCreateWithHttpInfo($api_key, $v, $content_type, $body, $account_id);
    }

    /**
     * Operation reviewInvitationsCreateWithHttpInfo
     *
     * Review Invitations: Create
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewInvitations3ACreateRequest[] $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewInvitationsCreateWithHttpInfo($api_key, $v, $content_type, $body, $account_id)
    {
        $returnType = '';
        $request = $this->reviewInvitationsCreateRequest($api_key, $v, $content_type, $body, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reviewInvitationsCreateAsync
     *
     * Review Invitations: Create
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewInvitations3ACreateRequest[] $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewInvitationsCreateAsync($api_key, $v, $content_type, $body, $account_id)
    {
        return $this->reviewInvitationsCreateAsyncWithHttpInfo($api_key, $v, $content_type, $body, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewInvitationsCreateAsyncWithHttpInfo
     *
     * Review Invitations: Create
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewInvitations3ACreateRequest[] $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewInvitationsCreateAsyncWithHttpInfo($api_key, $v, $content_type, $body, $account_id)
    {
        $returnType = '';
        $request = $this->reviewInvitationsCreateRequest($api_key, $v, $content_type, $body, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewInvitationsCreate'
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewInvitations3ACreateRequest[] $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewInvitationsCreateRequest($api_key, $v, $content_type, $body, $account_id)
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling reviewInvitationsCreate'
            );
        }
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling reviewInvitationsCreate'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling reviewInvitationsCreate'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling reviewInvitationsCreate'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling reviewInvitationsCreate'
            );
        }

        $resourcePath = '/accounts/{accountId}/reviewinvites';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['api_key'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($v !== null) {
            $queryParams['v'] = ObjectSerializer::toQueryValue($v);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewInvitationsList
     *
     * Review Invitations: List
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $limit  (required)
     * @param  string $offset  (required)
     * @param  string $location_ids  (required)
     * @param  string $folder_ids  (required)
     * @param  string $location_labels  (required)
     * @param  string $template_ids  (required)
     * @param  string $status  (required)
     * @param  string $type  (required)
     * @param  string $account_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reviewInvitationsList($api_key, $v, $limit, $offset, $location_ids, $folder_ids, $location_labels, $template_ids, $status, $type, $account_id)
    {
        $this->reviewInvitationsListWithHttpInfo($api_key, $v, $limit, $offset, $location_ids, $folder_ids, $location_labels, $template_ids, $status, $type, $account_id);
    }

    /**
     * Operation reviewInvitationsListWithHttpInfo
     *
     * Review Invitations: List
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $limit  (required)
     * @param  string $offset  (required)
     * @param  string $location_ids  (required)
     * @param  string $folder_ids  (required)
     * @param  string $location_labels  (required)
     * @param  string $template_ids  (required)
     * @param  string $status  (required)
     * @param  string $type  (required)
     * @param  string $account_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewInvitationsListWithHttpInfo($api_key, $v, $limit, $offset, $location_ids, $folder_ids, $location_labels, $template_ids, $status, $type, $account_id)
    {
        $returnType = '';
        $request = $this->reviewInvitationsListRequest($api_key, $v, $limit, $offset, $location_ids, $folder_ids, $location_labels, $template_ids, $status, $type, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reviewInvitationsListAsync
     *
     * Review Invitations: List
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $limit  (required)
     * @param  string $offset  (required)
     * @param  string $location_ids  (required)
     * @param  string $folder_ids  (required)
     * @param  string $location_labels  (required)
     * @param  string $template_ids  (required)
     * @param  string $status  (required)
     * @param  string $type  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewInvitationsListAsync($api_key, $v, $limit, $offset, $location_ids, $folder_ids, $location_labels, $template_ids, $status, $type, $account_id)
    {
        return $this->reviewInvitationsListAsyncWithHttpInfo($api_key, $v, $limit, $offset, $location_ids, $folder_ids, $location_labels, $template_ids, $status, $type, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewInvitationsListAsyncWithHttpInfo
     *
     * Review Invitations: List
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $limit  (required)
     * @param  string $offset  (required)
     * @param  string $location_ids  (required)
     * @param  string $folder_ids  (required)
     * @param  string $location_labels  (required)
     * @param  string $template_ids  (required)
     * @param  string $status  (required)
     * @param  string $type  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewInvitationsListAsyncWithHttpInfo($api_key, $v, $limit, $offset, $location_ids, $folder_ids, $location_labels, $template_ids, $status, $type, $account_id)
    {
        $returnType = '';
        $request = $this->reviewInvitationsListRequest($api_key, $v, $limit, $offset, $location_ids, $folder_ids, $location_labels, $template_ids, $status, $type, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewInvitationsList'
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $limit  (required)
     * @param  string $offset  (required)
     * @param  string $location_ids  (required)
     * @param  string $folder_ids  (required)
     * @param  string $location_labels  (required)
     * @param  string $template_ids  (required)
     * @param  string $status  (required)
     * @param  string $type  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewInvitationsListRequest($api_key, $v, $limit, $offset, $location_ids, $folder_ids, $location_labels, $template_ids, $status, $type, $account_id)
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling reviewInvitationsList'
            );
        }
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling reviewInvitationsList'
            );
        }
        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling reviewInvitationsList'
            );
        }
        // verify the required parameter 'offset' is set
        if ($offset === null || (is_array($offset) && count($offset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling reviewInvitationsList'
            );
        }
        // verify the required parameter 'location_ids' is set
        if ($location_ids === null || (is_array($location_ids) && count($location_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_ids when calling reviewInvitationsList'
            );
        }
        // verify the required parameter 'folder_ids' is set
        if ($folder_ids === null || (is_array($folder_ids) && count($folder_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_ids when calling reviewInvitationsList'
            );
        }
        // verify the required parameter 'location_labels' is set
        if ($location_labels === null || (is_array($location_labels) && count($location_labels) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_labels when calling reviewInvitationsList'
            );
        }
        // verify the required parameter 'template_ids' is set
        if ($template_ids === null || (is_array($template_ids) && count($template_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_ids when calling reviewInvitationsList'
            );
        }
        // verify the required parameter 'status' is set
        if ($status === null || (is_array($status) && count($status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $status when calling reviewInvitationsList'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling reviewInvitationsList'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling reviewInvitationsList'
            );
        }

        $resourcePath = '/accounts/{accountId}/reviewinvites';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['api_key'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($v !== null) {
            $queryParams['v'] = ObjectSerializer::toQueryValue($v);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($location_ids !== null) {
            $queryParams['locationIds'] = ObjectSerializer::toQueryValue($location_ids);
        }
        // query params
        if ($folder_ids !== null) {
            $queryParams['folderIds'] = ObjectSerializer::toQueryValue($folder_ids);
        }
        // query params
        if ($location_labels !== null) {
            $queryParams['locationLabels'] = ObjectSerializer::toQueryValue($location_labels);
        }
        // query params
        if ($template_ids !== null) {
            $queryParams['templateIds'] = ObjectSerializer::toQueryValue($template_ids);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsCreate
     *
     * Reviews: Create
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewsCreateRequest $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reviewsCreate($api_key, $v, $content_type, $body, $account_id)
    {
        $this->reviewsCreateWithHttpInfo($api_key, $v, $content_type, $body, $account_id);
    }

    /**
     * Operation reviewsCreateWithHttpInfo
     *
     * Reviews: Create
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewsCreateRequest $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsCreateWithHttpInfo($api_key, $v, $content_type, $body, $account_id)
    {
        $returnType = '';
        $request = $this->reviewsCreateRequest($api_key, $v, $content_type, $body, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsCreateAsync
     *
     * Reviews: Create
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewsCreateRequest $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsCreateAsync($api_key, $v, $content_type, $body, $account_id)
    {
        return $this->reviewsCreateAsyncWithHttpInfo($api_key, $v, $content_type, $body, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsCreateAsyncWithHttpInfo
     *
     * Reviews: Create
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewsCreateRequest $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsCreateAsyncWithHttpInfo($api_key, $v, $content_type, $body, $account_id)
    {
        $returnType = '';
        $request = $this->reviewsCreateRequest($api_key, $v, $content_type, $body, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsCreate'
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewsCreateRequest $body  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsCreateRequest($api_key, $v, $content_type, $body, $account_id)
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling reviewsCreate'
            );
        }
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling reviewsCreate'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling reviewsCreate'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling reviewsCreate'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling reviewsCreate'
            );
        }

        $resourcePath = '/accounts/{accountId}/reviews';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['api_key'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($v !== null) {
            $queryParams['v'] = ObjectSerializer::toQueryValue($v);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsGet
     *
     * Reviews: Get
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reviewsGet($api_key, $v, $account_id, $review_id)
    {
        $this->reviewsGetWithHttpInfo($api_key, $v, $account_id, $review_id);
    }

    /**
     * Operation reviewsGetWithHttpInfo
     *
     * Reviews: Get
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsGetWithHttpInfo($api_key, $v, $account_id, $review_id)
    {
        $returnType = '';
        $request = $this->reviewsGetRequest($api_key, $v, $account_id, $review_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsGetAsync
     *
     * Reviews: Get
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsGetAsync($api_key, $v, $account_id, $review_id)
    {
        return $this->reviewsGetAsyncWithHttpInfo($api_key, $v, $account_id, $review_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsGetAsyncWithHttpInfo
     *
     * Reviews: Get
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsGetAsyncWithHttpInfo($api_key, $v, $account_id, $review_id)
    {
        $returnType = '';
        $request = $this->reviewsGetRequest($api_key, $v, $account_id, $review_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsGet'
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsGetRequest($api_key, $v, $account_id, $review_id)
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling reviewsGet'
            );
        }
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling reviewsGet'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling reviewsGet'
            );
        }
        // verify the required parameter 'review_id' is set
        if ($review_id === null || (is_array($review_id) && count($review_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $review_id when calling reviewsGet'
            );
        }

        $resourcePath = '/accounts/{accountId}/reviews/{reviewId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['api_key'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($v !== null) {
            $queryParams['v'] = ObjectSerializer::toQueryValue($v);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($review_id !== null) {
            $resourcePath = str_replace(
                '{' . 'reviewId' . '}',
                ObjectSerializer::toPathValue($review_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsList
     *
     * Reviews: List
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $limit  (required)
     * @param  string $offset  (required)
     * @param  string $location_ids  (required)
     * @param  string $folder_id  (required)
     * @param  string $countries  (required)
     * @param  string $location_labels  (required)
     * @param  string $publisher_ids  (required)
     * @param  string $review_content  (required)
     * @param  string $min_rating  (required)
     * @param  string $max_rating  (required)
     * @param  string $min_publisher_date  (required)
     * @param  string $max_publisher_date  (required)
     * @param  string $min_last_yext_update_date  (required)
     * @param  string $max_last_yext_update_date  (required)
     * @param  string $awaiting_response  (required)
     * @param  string $min_non_owner_comments  (required)
     * @param  string $reviewer_name  (required)
     * @param  string $reviewer_email  (required)
     * @param  string $status  (required)
     * @param  string $page_token  (required)
     * @param  string $account_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reviewsList($api_key, $v, $limit, $offset, $location_ids, $folder_id, $countries, $location_labels, $publisher_ids, $review_content, $min_rating, $max_rating, $min_publisher_date, $max_publisher_date, $min_last_yext_update_date, $max_last_yext_update_date, $awaiting_response, $min_non_owner_comments, $reviewer_name, $reviewer_email, $status, $page_token, $account_id)
    {
        $this->reviewsListWithHttpInfo($api_key, $v, $limit, $offset, $location_ids, $folder_id, $countries, $location_labels, $publisher_ids, $review_content, $min_rating, $max_rating, $min_publisher_date, $max_publisher_date, $min_last_yext_update_date, $max_last_yext_update_date, $awaiting_response, $min_non_owner_comments, $reviewer_name, $reviewer_email, $status, $page_token, $account_id);
    }

    /**
     * Operation reviewsListWithHttpInfo
     *
     * Reviews: List
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $limit  (required)
     * @param  string $offset  (required)
     * @param  string $location_ids  (required)
     * @param  string $folder_id  (required)
     * @param  string $countries  (required)
     * @param  string $location_labels  (required)
     * @param  string $publisher_ids  (required)
     * @param  string $review_content  (required)
     * @param  string $min_rating  (required)
     * @param  string $max_rating  (required)
     * @param  string $min_publisher_date  (required)
     * @param  string $max_publisher_date  (required)
     * @param  string $min_last_yext_update_date  (required)
     * @param  string $max_last_yext_update_date  (required)
     * @param  string $awaiting_response  (required)
     * @param  string $min_non_owner_comments  (required)
     * @param  string $reviewer_name  (required)
     * @param  string $reviewer_email  (required)
     * @param  string $status  (required)
     * @param  string $page_token  (required)
     * @param  string $account_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsListWithHttpInfo($api_key, $v, $limit, $offset, $location_ids, $folder_id, $countries, $location_labels, $publisher_ids, $review_content, $min_rating, $max_rating, $min_publisher_date, $max_publisher_date, $min_last_yext_update_date, $max_last_yext_update_date, $awaiting_response, $min_non_owner_comments, $reviewer_name, $reviewer_email, $status, $page_token, $account_id)
    {
        $returnType = '';
        $request = $this->reviewsListRequest($api_key, $v, $limit, $offset, $location_ids, $folder_id, $countries, $location_labels, $publisher_ids, $review_content, $min_rating, $max_rating, $min_publisher_date, $max_publisher_date, $min_last_yext_update_date, $max_last_yext_update_date, $awaiting_response, $min_non_owner_comments, $reviewer_name, $reviewer_email, $status, $page_token, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsListAsync
     *
     * Reviews: List
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $limit  (required)
     * @param  string $offset  (required)
     * @param  string $location_ids  (required)
     * @param  string $folder_id  (required)
     * @param  string $countries  (required)
     * @param  string $location_labels  (required)
     * @param  string $publisher_ids  (required)
     * @param  string $review_content  (required)
     * @param  string $min_rating  (required)
     * @param  string $max_rating  (required)
     * @param  string $min_publisher_date  (required)
     * @param  string $max_publisher_date  (required)
     * @param  string $min_last_yext_update_date  (required)
     * @param  string $max_last_yext_update_date  (required)
     * @param  string $awaiting_response  (required)
     * @param  string $min_non_owner_comments  (required)
     * @param  string $reviewer_name  (required)
     * @param  string $reviewer_email  (required)
     * @param  string $status  (required)
     * @param  string $page_token  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsListAsync($api_key, $v, $limit, $offset, $location_ids, $folder_id, $countries, $location_labels, $publisher_ids, $review_content, $min_rating, $max_rating, $min_publisher_date, $max_publisher_date, $min_last_yext_update_date, $max_last_yext_update_date, $awaiting_response, $min_non_owner_comments, $reviewer_name, $reviewer_email, $status, $page_token, $account_id)
    {
        return $this->reviewsListAsyncWithHttpInfo($api_key, $v, $limit, $offset, $location_ids, $folder_id, $countries, $location_labels, $publisher_ids, $review_content, $min_rating, $max_rating, $min_publisher_date, $max_publisher_date, $min_last_yext_update_date, $max_last_yext_update_date, $awaiting_response, $min_non_owner_comments, $reviewer_name, $reviewer_email, $status, $page_token, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsListAsyncWithHttpInfo
     *
     * Reviews: List
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $limit  (required)
     * @param  string $offset  (required)
     * @param  string $location_ids  (required)
     * @param  string $folder_id  (required)
     * @param  string $countries  (required)
     * @param  string $location_labels  (required)
     * @param  string $publisher_ids  (required)
     * @param  string $review_content  (required)
     * @param  string $min_rating  (required)
     * @param  string $max_rating  (required)
     * @param  string $min_publisher_date  (required)
     * @param  string $max_publisher_date  (required)
     * @param  string $min_last_yext_update_date  (required)
     * @param  string $max_last_yext_update_date  (required)
     * @param  string $awaiting_response  (required)
     * @param  string $min_non_owner_comments  (required)
     * @param  string $reviewer_name  (required)
     * @param  string $reviewer_email  (required)
     * @param  string $status  (required)
     * @param  string $page_token  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsListAsyncWithHttpInfo($api_key, $v, $limit, $offset, $location_ids, $folder_id, $countries, $location_labels, $publisher_ids, $review_content, $min_rating, $max_rating, $min_publisher_date, $max_publisher_date, $min_last_yext_update_date, $max_last_yext_update_date, $awaiting_response, $min_non_owner_comments, $reviewer_name, $reviewer_email, $status, $page_token, $account_id)
    {
        $returnType = '';
        $request = $this->reviewsListRequest($api_key, $v, $limit, $offset, $location_ids, $folder_id, $countries, $location_labels, $publisher_ids, $review_content, $min_rating, $max_rating, $min_publisher_date, $max_publisher_date, $min_last_yext_update_date, $max_last_yext_update_date, $awaiting_response, $min_non_owner_comments, $reviewer_name, $reviewer_email, $status, $page_token, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsList'
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $limit  (required)
     * @param  string $offset  (required)
     * @param  string $location_ids  (required)
     * @param  string $folder_id  (required)
     * @param  string $countries  (required)
     * @param  string $location_labels  (required)
     * @param  string $publisher_ids  (required)
     * @param  string $review_content  (required)
     * @param  string $min_rating  (required)
     * @param  string $max_rating  (required)
     * @param  string $min_publisher_date  (required)
     * @param  string $max_publisher_date  (required)
     * @param  string $min_last_yext_update_date  (required)
     * @param  string $max_last_yext_update_date  (required)
     * @param  string $awaiting_response  (required)
     * @param  string $min_non_owner_comments  (required)
     * @param  string $reviewer_name  (required)
     * @param  string $reviewer_email  (required)
     * @param  string $status  (required)
     * @param  string $page_token  (required)
     * @param  string $account_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsListRequest($api_key, $v, $limit, $offset, $location_ids, $folder_id, $countries, $location_labels, $publisher_ids, $review_content, $min_rating, $max_rating, $min_publisher_date, $max_publisher_date, $min_last_yext_update_date, $max_last_yext_update_date, $awaiting_response, $min_non_owner_comments, $reviewer_name, $reviewer_email, $status, $page_token, $account_id)
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling reviewsList'
            );
        }
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling reviewsList'
            );
        }
        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling reviewsList'
            );
        }
        // verify the required parameter 'offset' is set
        if ($offset === null || (is_array($offset) && count($offset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling reviewsList'
            );
        }
        // verify the required parameter 'location_ids' is set
        if ($location_ids === null || (is_array($location_ids) && count($location_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_ids when calling reviewsList'
            );
        }
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling reviewsList'
            );
        }
        // verify the required parameter 'countries' is set
        if ($countries === null || (is_array($countries) && count($countries) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $countries when calling reviewsList'
            );
        }
        // verify the required parameter 'location_labels' is set
        if ($location_labels === null || (is_array($location_labels) && count($location_labels) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_labels when calling reviewsList'
            );
        }
        // verify the required parameter 'publisher_ids' is set
        if ($publisher_ids === null || (is_array($publisher_ids) && count($publisher_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publisher_ids when calling reviewsList'
            );
        }
        // verify the required parameter 'review_content' is set
        if ($review_content === null || (is_array($review_content) && count($review_content) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $review_content when calling reviewsList'
            );
        }
        // verify the required parameter 'min_rating' is set
        if ($min_rating === null || (is_array($min_rating) && count($min_rating) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $min_rating when calling reviewsList'
            );
        }
        // verify the required parameter 'max_rating' is set
        if ($max_rating === null || (is_array($max_rating) && count($max_rating) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $max_rating when calling reviewsList'
            );
        }
        // verify the required parameter 'min_publisher_date' is set
        if ($min_publisher_date === null || (is_array($min_publisher_date) && count($min_publisher_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $min_publisher_date when calling reviewsList'
            );
        }
        // verify the required parameter 'max_publisher_date' is set
        if ($max_publisher_date === null || (is_array($max_publisher_date) && count($max_publisher_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $max_publisher_date when calling reviewsList'
            );
        }
        // verify the required parameter 'min_last_yext_update_date' is set
        if ($min_last_yext_update_date === null || (is_array($min_last_yext_update_date) && count($min_last_yext_update_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $min_last_yext_update_date when calling reviewsList'
            );
        }
        // verify the required parameter 'max_last_yext_update_date' is set
        if ($max_last_yext_update_date === null || (is_array($max_last_yext_update_date) && count($max_last_yext_update_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $max_last_yext_update_date when calling reviewsList'
            );
        }
        // verify the required parameter 'awaiting_response' is set
        if ($awaiting_response === null || (is_array($awaiting_response) && count($awaiting_response) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $awaiting_response when calling reviewsList'
            );
        }
        // verify the required parameter 'min_non_owner_comments' is set
        if ($min_non_owner_comments === null || (is_array($min_non_owner_comments) && count($min_non_owner_comments) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $min_non_owner_comments when calling reviewsList'
            );
        }
        // verify the required parameter 'reviewer_name' is set
        if ($reviewer_name === null || (is_array($reviewer_name) && count($reviewer_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reviewer_name when calling reviewsList'
            );
        }
        // verify the required parameter 'reviewer_email' is set
        if ($reviewer_email === null || (is_array($reviewer_email) && count($reviewer_email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reviewer_email when calling reviewsList'
            );
        }
        // verify the required parameter 'status' is set
        if ($status === null || (is_array($status) && count($status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $status when calling reviewsList'
            );
        }
        // verify the required parameter 'page_token' is set
        if ($page_token === null || (is_array($page_token) && count($page_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_token when calling reviewsList'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling reviewsList'
            );
        }

        $resourcePath = '/accounts/{accountId}/reviews';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['api_key'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($v !== null) {
            $queryParams['v'] = ObjectSerializer::toQueryValue($v);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($location_ids !== null) {
            $queryParams['locationIds'] = ObjectSerializer::toQueryValue($location_ids);
        }
        // query params
        if ($folder_id !== null) {
            $queryParams['folderId'] = ObjectSerializer::toQueryValue($folder_id);
        }
        // query params
        if ($countries !== null) {
            $queryParams['countries'] = ObjectSerializer::toQueryValue($countries);
        }
        // query params
        if ($location_labels !== null) {
            $queryParams['locationLabels'] = ObjectSerializer::toQueryValue($location_labels);
        }
        // query params
        if ($publisher_ids !== null) {
            $queryParams['publisherIds'] = ObjectSerializer::toQueryValue($publisher_ids);
        }
        // query params
        if ($review_content !== null) {
            $queryParams['reviewContent'] = ObjectSerializer::toQueryValue($review_content);
        }
        // query params
        if ($min_rating !== null) {
            $queryParams['minRating'] = ObjectSerializer::toQueryValue($min_rating);
        }
        // query params
        if ($max_rating !== null) {
            $queryParams['maxRating'] = ObjectSerializer::toQueryValue($max_rating);
        }
        // query params
        if ($min_publisher_date !== null) {
            $queryParams['minPublisherDate'] = ObjectSerializer::toQueryValue($min_publisher_date);
        }
        // query params
        if ($max_publisher_date !== null) {
            $queryParams['maxPublisherDate'] = ObjectSerializer::toQueryValue($max_publisher_date);
        }
        // query params
        if ($min_last_yext_update_date !== null) {
            $queryParams['minLastYextUpdateDate'] = ObjectSerializer::toQueryValue($min_last_yext_update_date);
        }
        // query params
        if ($max_last_yext_update_date !== null) {
            $queryParams['maxLastYextUpdateDate'] = ObjectSerializer::toQueryValue($max_last_yext_update_date);
        }
        // query params
        if ($awaiting_response !== null) {
            $queryParams['awaitingResponse'] = ObjectSerializer::toQueryValue($awaiting_response);
        }
        // query params
        if ($min_non_owner_comments !== null) {
            $queryParams['minNonOwnerComments'] = ObjectSerializer::toQueryValue($min_non_owner_comments);
        }
        // query params
        if ($reviewer_name !== null) {
            $queryParams['reviewerName'] = ObjectSerializer::toQueryValue($reviewer_name);
        }
        // query params
        if ($reviewer_email !== null) {
            $queryParams['reviewerEmail'] = ObjectSerializer::toQueryValue($reviewer_email);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($page_token !== null) {
            $queryParams['pageToken'] = ObjectSerializer::toQueryValue($page_token);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reviewsUpdate
     *
     * Reviews: Update
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewsUpdateRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reviewsUpdate($api_key, $v, $content_type, $body, $account_id, $review_id)
    {
        $this->reviewsUpdateWithHttpInfo($api_key, $v, $content_type, $body, $account_id, $review_id);
    }

    /**
     * Operation reviewsUpdateWithHttpInfo
     *
     * Reviews: Update
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewsUpdateRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewsUpdateWithHttpInfo($api_key, $v, $content_type, $body, $account_id, $review_id)
    {
        $returnType = '';
        $request = $this->reviewsUpdateRequest($api_key, $v, $content_type, $body, $account_id, $review_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reviewsUpdateAsync
     *
     * Reviews: Update
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewsUpdateRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsUpdateAsync($api_key, $v, $content_type, $body, $account_id, $review_id)
    {
        return $this->reviewsUpdateAsyncWithHttpInfo($api_key, $v, $content_type, $body, $account_id, $review_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewsUpdateAsyncWithHttpInfo
     *
     * Reviews: Update
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewsUpdateRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewsUpdateAsyncWithHttpInfo($api_key, $v, $content_type, $body, $account_id, $review_id)
    {
        $returnType = '';
        $request = $this->reviewsUpdateRequest($api_key, $v, $content_type, $body, $account_id, $review_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reviewsUpdate'
     *
     * @param  string $api_key  (required)
     * @param  string $v  (required)
     * @param  string $content_type  (required)
     * @param  \Swagger\Client\Model\ReviewsUpdateRequest $body  (required)
     * @param  string $account_id  (required)
     * @param  string $review_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewsUpdateRequest($api_key, $v, $content_type, $body, $account_id, $review_id)
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling reviewsUpdate'
            );
        }
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling reviewsUpdate'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling reviewsUpdate'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling reviewsUpdate'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling reviewsUpdate'
            );
        }
        // verify the required parameter 'review_id' is set
        if ($review_id === null || (is_array($review_id) && count($review_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $review_id when calling reviewsUpdate'
            );
        }

        $resourcePath = '/accounts/{accountId}/reviews/{reviewId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['api_key'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($v !== null) {
            $queryParams['v'] = ObjectSerializer::toQueryValue($v);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($review_id !== null) {
            $resourcePath = str_replace(
                '{' . 'reviewId' . '}',
                ObjectSerializer::toPathValue($review_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
